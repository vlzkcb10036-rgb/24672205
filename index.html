<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ëƒ ëƒ  ë¨¹ë°© ê²Œì„</title>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Jua', sans-serif;
            background-color: #FFF3E0; /* ë§›ìˆëŠ” ìƒ‰ ë°°ê²½ */
            text-align: center;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        h1 { color: #FF6F00; margin: 10px 0; font-size: 3rem; text-shadow: 2px 2px #fff; }

        /* ê²Œì„ ì»¨í…Œì´ë„ˆ: ì›¹ìº ê³¼ ê²Œì„ í™”ë©´ì„ ê²¹ì¹˜ê¸° ìœ„í•¨ */
        .game-container {
            position: relative;
            width: 400px;
            height: 400px;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            background-color: #000;
        }

        /* ì›¹ìº  ë¹„ë””ì˜¤ (ë’¤ìª½) */
        #webcam-container canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* ê²Œì„ ì˜¤ë²„ë ˆì´ ìº”ë²„ìŠ¤ (ì•ìª½) */
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 400px;
            height: 400px;
            z-index: 10; /* ì›¹ìº  ìœ„ì— ìœ„ì¹˜ */
        }

        /* UI ìš”ì†Œ */
        .score-board {
            font-size: 2rem;
            color: #333;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 20px;
            border-radius: 50px;
        }

        button {
            background-color: #FF6F00;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: 'Jua', sans-serif;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 0 #E65100;
            transition: transform 0.1s;
            margin-top: 20px;
        }

        button:active {
            transform: translateY(5px);
            box-shadow: none;
        }

        /* ìƒíƒœ í‘œì‹œë°” (ë””ë²„ê¹…ìš©) */
        #status-bar {
            margin-top: 10px;
            font-size: 1.2rem;
            color: #666;
        }
        
        .mouth-open { color: #d32f2f; }
        .mouth-closed { color: #388e3c; }

    </style>
</head>
<body>

    <h1>ğŸ˜² ëƒ ëƒ  ë¨¹ë°© ê²Œì„</h1>
    
    <div class="score-board">ì ìˆ˜: <span id="score">0</span></div>

    <div class="game-container">
        <div id="webcam-container"></div>
        <canvas id="game-canvas" width="400" height="400"></canvas>
    </div>

    <div id="status-bar">ì¤€ë¹„ë˜ë©´ ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”!</div>
    
    <button type="button" onclick="init()" id="start-btn">ê²Œì„ ì‹œì‘!</button>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
    <script type="text/javascript">
        // --------------------------------------------------
        // [ì„¤ì • ì˜ì—­] ì„ ìƒë‹˜ì´ í•™ìŠµì‹œí‚¨ ì´ë¦„ê³¼ ë˜‘ê°™ì´ ì ì–´ì£¼ì„¸ìš”!
        // --------------------------------------------------
        const URL = "https://teachablemachine.withgoogle.com/models/VCE0P0TSD/";
        const CLASS_NAMES = {
            OPEN: "ì…ë²Œë¦¼",   // í‹°ì²˜ë¸”ë¨¸ì‹  í´ë˜ìŠ¤ ì´ë¦„ 1
            CLOSED: "ì…ë‹¤ë­„"  // í‹°ì²˜ë¸”ë¨¸ì‹  í´ë˜ìŠ¤ ì´ë¦„ 2
        };
        // --------------------------------------------------

        let model, webcam, maxPredictions;
        let isModelLoaded = false;
        let isMouthOpen = false; // í˜„ì¬ ì… ìƒíƒœ
        
        // ê²Œì„ ê´€ë ¨ ë³€ìˆ˜
        let score = 0;
        let isPlaying = false;
        let items = []; // ë–¨ì–´ì§€ëŠ” ìŒì‹/í­íƒ„ë“¤
        let spawnRate = 60; // ì•„ì´í…œ ìƒì„± ì£¼ê¸° (í”„ë ˆì„ ë‹¨ìœ„)
        let frameCount = 0;
        let gameSpeed = 3; // ë–¨ì–´ì§€ëŠ” ì†ë„

        const canvas = document.getElementById("game-canvas");
        const ctx = canvas.getContext("2d");
        const scoreEl = document.getElementById("score");
        const statusEl = document.getElementById("status-bar");
        const btnEl = document.getElementById("start-btn");

        // ì•„ì´í…œ ì¢…ë¥˜ (ì´ëª¨ì§€)
        const FOODS = ['ğŸ', 'ğŸ•', 'ğŸ–', 'ğŸ©', 'ğŸ“'];
        const BOMBS = ['ğŸ’£', 'ğŸª¨']; // í­íƒ„, ëŒ

        // 1. ì´ˆê¸°í™” ë° ëª¨ë¸ ë¡œë“œ
        async function init() {
            if (isPlaying) return; // ê²Œì„ ì¤‘ í´ë¦­ ë°©ì§€

            btnEl.disabled = true;
            btnEl.innerText = "ë¡œë”© ì¤‘...";

            if (!isModelLoaded) {
                const modelURL = URL + "model.json";
                const metadataURL = URL + "metadata.json";

                try {
                    model = await tmImage.load(modelURL, metadataURL);
                    maxPredictions = model.getTotalClasses();

                    const flip = true; 
                    webcam = new tmImage.Webcam(400, 400, flip); // ìº”ë²„ìŠ¤ í¬ê¸°ì— ë§ì¶¤
                    await webcam.setup();
                    await webcam.play();
                    window.requestAnimationFrame(loop);

                    document.getElementById("webcam-container").appendChild(webcam.canvas);
                    isModelLoaded = true;
                } catch (e) {
                    alert("ì¹´ë©”ë¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”!");
                    btnEl.disabled = false;
                    btnEl.innerText = "ë‹¤ì‹œ ì‹œë„";
                    return;
                }
            }

            startGame();
        }

        // 2. ê²Œì„ ì‹œì‘ ì„¸íŒ…
        function startGame() {
            score = 0;
            items = [];
            isPlaying = true;
            scoreEl.innerText = score;
            statusEl.innerText = "ì…ì„ í¬ê²Œ ë²Œë ¤ ìŒì‹ì„ ë“œì„¸ìš”!";
            btnEl.style.display = 'none'; // ê²Œì„ ì¤‘ ë²„íŠ¼ ìˆ¨ê¹€
        }

        // 3. ë©”ì¸ ë£¨í”„ (ì›¹ìº  + ê²Œì„ë¡œì§)
        async function loop() {
            webcam.update(); 
            await predict(); // ì… ëª¨ì–‘ íŒë‹¨
            
            if (isPlaying) {
                updateGame(); // ê²Œì„ ì§„í–‰
                drawGame();   // ê²Œì„ í™”ë©´ ê·¸ë¦¬ê¸°
            }

            window.requestAnimationFrame(loop);
        }

        // 4. ì… ëª¨ì–‘ ì˜ˆì¸¡
        async function predict() {
            const prediction = await model.predict(webcam.canvas);
            
            // í™•ë¥ ì´ ê°€ì¥ ë†’ì€ í´ë˜ìŠ¤ ì°¾ê¸°
            let maxProb = 0;
            let className = "";
            
            for (let i = 0; i < maxPredictions; i++) {
                if (prediction[i].probability > maxProb) {
                    maxProb = prediction[i].probability;
                    className = prediction[i].className;
                }
            }

            // í™•ë¥  80% ì´ìƒì¼ ë•Œë§Œ ìƒíƒœ ë³€ê²½ (ë–¨ë¦¼ ë°©ì§€)
            if (maxProb > 0.8) {
                if (className === CLASS_NAMES.OPEN) {
                    isMouthOpen = true;
                    statusEl.innerText = "ğŸ˜² ì•„~~ (ì… ë²Œë¦¼)";
                    statusEl.className = "mouth-open";
                } else if (className === CLASS_NAMES.CLOSED) {
                    isMouthOpen = false;
                    statusEl.innerText = "ğŸ˜ í .. (ì… ë‹¤ë­„)";
                    statusEl.className = "mouth-closed";
                }
            }
        }

        // 5. ê²Œì„ ë¡œì§ ì—…ë°ì´íŠ¸ (ë¬¼ë¦¬ ì—”ì§„)
        function updateGame() {
            frameCount++;

            // ì¼ì • ì‹œê°„ë§ˆë‹¤ ì•„ì´í…œ ìƒì„±
            if (frameCount % spawnRate === 0) {
                spawnItem();
            }

            // ë‚œì´ë„ ì¡°ì ˆ: ì ìˆ˜ê°€ ì˜¤ë¥´ë©´ ì†ë„ ë¹¨ë¼ì§
            gameSpeed = 3 + (score / 100);

            // ì•„ì´í…œ ì´ë™ ë° ì¶©ëŒ ì²´í¬
            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                item.y += gameSpeed;

                // í™”ë©´ ì•„ë˜(ì… ìœ„ì¹˜)ì— ë„ë‹¬í–ˆëŠ”ì§€ í™•ì¸
                if (item.y > 350) { 
                    // ì¶©ëŒ íŒì • ì¡´ (y: 350~400)
                    checkCollision(item);
                    items.splice(i, 1); // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ê±°ë‚˜ ë¨¹íˆë©´ ì œê±°
                }
            }
        }

        // 6. ì¶©ëŒ íŒì • (í•µì‹¬ ë¡œì§)
        function checkCollision(item) {
            if (isMouthOpen) {
                // ì…ì„ ë²Œë¦¬ê³  ìˆì„ ë•Œ
                if (item.type === 'food') {
                    // ìŒì‹ -> ì ìˆ˜ íšë“
                    score += 10;
                    scoreEl.innerText = score;
                    // ë¨¹ëŠ” íš¨ê³¼ (ê°„ë‹¨íˆ í…ìŠ¤íŠ¸ë¡œ)
                    showEffect(item.x, "ëƒ ëƒ ! +10", "#4CAF50");
                } else {
                    // í­íƒ„ -> ê²Œì„ ì˜¤ë²„
                    gameOver();
                }
            } else {
                // ì…ì„ ë‹¤ë¬¼ê³  ìˆì„ ë•Œ
                if (item.type === 'food') {
                    // ìŒì‹ -> ê·¸ëƒ¥ ì§€ë‚˜ê° (ì•„ê¹Œì›Œ!)
                } else {
                    // í­íƒ„ -> ë°©ì–´ ì„±ê³µ!
                    showEffect(item.x, "ë°©ì–´! +5", "#2196F3");
                    score += 5; // ë°©ì–´ ì ìˆ˜
                    scoreEl.innerText = score;
                }
            }
        }

        // ì•„ì´í…œ ìƒì„± í•¨ìˆ˜
        function spawnItem() {
            const isBomb = Math.random() < 0.2; // 20% í™•ë¥ ë¡œ í­íƒ„
            const content = isBomb ? 
                BOMBS[Math.floor(Math.random() * BOMBS.length)] : 
                FOODS[Math.floor(Math.random() * FOODS.length)];
            
            items.push({
                x: Math.random() * 360 + 20, // ëœë¤ X ìœ„ì¹˜
                y: -50,
                type: isBomb ? 'bomb' : 'food',
                text: content
            });
        }

        // 7. í™”ë©´ ê·¸ë¦¬ê¸°
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // í™”ë©´ ì§€ìš°ê¸°

            // ì•„ì´í…œ ê·¸ë¦¬ê¸°
            ctx.font = "40px Arial";
            ctx.textAlign = "center";
            for (let item of items) {
                ctx.fillText(item.text, item.x, item.y);
            }

            // ì… ìœ„ì¹˜ ê°€ì´ë“œë¼ì¸ (ì„ íƒì‚¬í•­)
            ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
            ctx.fillRect(0, 350, 400, 50);
            
            // íš¨ê³¼ í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
            effects.forEach((eff, index) => {
                ctx.font = "bold 20px Jua";
                ctx.fillStyle = eff.color;
                ctx.fillText(eff.text, eff.x, eff.y);
                eff.y -= 1; // ìœ„ë¡œ ì˜¬ë¼ê°
                eff.life--;
                if(eff.life <= 0) effects.splice(index, 1);
            });
        }

        // ì´í™íŠ¸ ê´€ë¦¬
        let effects = [];
        function showEffect(x, text, color) {
            effects.push({ x: x, y: 350, text: text, color: color, life: 30 });
        }

        // 8. ê²Œì„ ì˜¤ë²„ ì²˜ë¦¬
        function gameOver() {
            isPlaying = false;
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = "white";
            ctx.font = "50px Jua";
            ctx.textAlign = "center";
            ctx.fillText("ê²Œì„ ì˜¤ë²„!", 200, 180);
            
            ctx.font = "30px Jua";
            ctx.fillText("ìµœì¢… ì ìˆ˜: " + score, 200, 240);

            btnEl.style.display = 'block';
            btnEl.innerText = "ë‹¤ì‹œ ë„ì „í•˜ê¸°";
            btnEl.disabled = false;
        }

    </script>
</body>
</html>
